#include <stdio.h>
#include <stdlib.h>

#define  TY unsigned
#define  QSORT_TY TY
#define  QS_(name) u4_##name
#include "qsort.c"
#include <time.h>
#include <string.h>
#include <sys/time.h>
#include "datetime/TIME.c"
#include <unistd.h>

enum generator {RAND,BOUNDED,SORTED, REVERSE ,IDENT} ;

long k,j;
const char* usage="qsort-cmp dist N trials\n"
"dist is one of: RAND, BOUNDED , SORTED, REVSORTED, IDENT\n"
"N:              size of the array.\n"
"trials:         how many trials to do.  Necessary for small N.\n";

int parseDist(char* dist_str) {
    if (!strcmp("BOUNDED",dist_str)) 
        return BOUNDED;
    else if (!strcmp("RAND",dist_str)) 
        return RAND;
    else if (!strcmp("SORTED",dist_str))
        return SORTED;
    else if (!strcmp("REVERSE",dist_str))
        return REVERSE;
    else if (!strcmp("IDENT",dist_str))
        return IDENT;
    else fprintf(stderr,"dist argument mismatch.\n%s\n",usage),exit(1);
}

void randomized(unsigned *x, long n) {
    long i;
    for (i = 0; i < n; i++) {
        x[i] = random();
    }
}

void bounded(unsigned *x, long n) {
    long i;
    for (i = 0; i < n; i++) {
        x[i] = random() % (n/4);
    }
}

void identity(unsigned *x, long n) {
    long i;
    for (i = 0; i < n; i++) {
        x[i] = 1;
    }
}

void reverse(unsigned *x, long n) {
    long i;
    for (i = 0; i < n; i++) 
        x[i] = n - i - 1;
}

void sorted(unsigned *x, long n) {
    long i;
    for (i = 0; i < n; i++) 
        x[i] = i;
}


int compare(const void *a, const void *b) {
    unsigned A = *(const unsigned *)a, B = *(const unsigned *)b;
    return (int) (A - B);
}

void fill(char* dist, TY* array1,long n) {
    switch (parseDist(dist)) {
    case RAND : 
        randomized(array1,n) ; break;
    case BOUNDED :
        bounded(array1,n) ;    break;
    case SORTED :
        sorted(array1,n)  ;    break;
    case REVERSE :
        reverse(array1,n) ;    break;
    case IDENT :
        identity(array1,n) ;    break;
    default :
        fprintf(stderr,"dist match error.\n"), exit(1);
    }
}

void checkWork(unsigned *a, long long n) {
    long long i,j;
    for (i = 1; i < n; i++) {
        if (a[i-1] > a[i]) {
            fprintf (stderr,"u4_sort: %lld x %zd: failure at offset %lld\n", n,
                     sizeof(TY), i);
            for (j=0; j < n;j++)
                fprintf(stderr,"%d ",a[j]);
            fprintf(stderr,"\n"); 
            free(a);
            exit(1);
        }
    }
}

int main (int argc, char **argv)
{
    if (argc < 4) fprintf(stderr,"too few arguments: %d\n%s",argc,usage) , exit(1);
    long i=j=0; long n=strtoul(argv[1],NULL,10);
    long num_trials = strtoul(argv[3],NULL,10);
    double start, end, m_tot=0, g_tot=0;
    TY *array1 = (TY*) malloc (n * sizeof(TY));
    if (array1 == NULL)
        {
            fprintf (stderr,"%zd x %zd: no memory\n", argc, sizeof(TY));
            return 1;
        }
    if (getenv("SEED")) srand(time(NULL)); /* default is debugging mode. */
    for (i = 0; i < num_trials; i++) {
        fill(argv[2],array1,n);
        start = TIME();
        qsort (array1,n,4,&compare);
        end   = TIME();
        if (i) {
            g_tot += end-start;
        }  
    }
    g_tot /= (double) (num_trials - 1);
    
    for (i = 0; i < num_trials; i++) {
        fill(argv[2],array1,n);
        start = TIME();
        u4_sort (array1,n);
        end   = TIME();
        if (i) {
            m_tot += end - start;
        }    
        checkWork(array1,n);
    
    }
    m_tot /= (double) (num_trials - 1);
    
        
    
    fprintf(stdout,"%10ld\t%5.10f\t%5.10f\t%2.2f\n",n,m_tot,g_tot,
            100*((g_tot/m_tot) - 1));
    free (array1);
    return 0; 
}






