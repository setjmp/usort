#include <stdio.h>
#include <stdlib.h>
#define QSORT_TY unsigned
#define TY unsigned
#define  QS_(x)        u4_##x
#include "qsort.c"
#include <time.h>
#include <string.h>
#include <sys/time.h>
#include "datetime/TIME.c"
#include <unistd.h>

#define  S_VAL_T unsigned
#define  S_IDX_T unsigned long
#define  S_LESS(x,y)   (*(x) <  *(y))
#define  S_LESSEQ(x,y) (*(x) <= *(y))
#define  S_EQ(x,y)     (*(x) == *(y))
#include "cb/gen/sort.c"

enum generator {RAND,BOUNDED,SORTED, REVERSE ,IDENT} ;

long k,j;
const char* usage="qsort-cmp dist N trials\n"
"dist is one of: RAND, BOUNDED , SORTED, REVSORTED, IDENT\n"
"N:              size of the array.\n"
"trials:         how many trials to do.  Necessary for small N.\n";

int parseDist(char* dist_str) {
    if (!strcmp("BOUNDED",dist_str)) 
        return BOUNDED;
    else if (!strcmp("RAND",dist_str)) 
        return RAND;
    else if (!strcmp("SORTED",dist_str))
        return SORTED;
    else if (!strcmp("REVERSE",dist_str))
        return REVERSE;
    else if (!strcmp("IDENT",dist_str))
        return IDENT;
    else fprintf(stderr,"dist argument mismatch.\n%s\n",usage),exit(1);
}

void randomized(unsigned *x, long n) {
    long i;
    for (i = 0; i < n; i++) {
        x[i] = random();
    }
}

void bounded(unsigned *x, long n) {
    long i;
    for (i = 0; i < n; i++) {
        x[i] = random() % (n/4);
    }
}

void identity(unsigned *x, long n) {
    long i;
    for (i = 0; i < n; i++) {
        x[i] = 1;
    }
}

void reverse(unsigned *x, long n) {
    long i;
    for (i = 0; i < n; i++) 
        x[i] = n - i - 1;
}

void sorted(unsigned *x, long n) {
    long i;
    for (i = 0; i < n; i++) 
        x[i] = i;
}


int compare(const void *a, const void *b) {
    unsigned A = *(const unsigned *)a, B = *(const unsigned *)b;
    return (int) (A - B);
}

void fill(char* dist, TY* array1,long n) {
    switch (parseDist(dist)) {
    case RAND : 
        randomized(array1,n) ; break;
    case BOUNDED :
        bounded(array1,n) ;    break;
    case SORTED :
        sorted(array1,n)  ;    break;
    case REVERSE :
        reverse(array1,n) ;    break;
    case IDENT :
        identity(array1,n) ;    break;
    default :
        fprintf(stderr,"dist match error.\n"), exit(1);
    }
}

int main (int argc, char **argv)
{
    if (argc < 4) fprintf(stderr,"too few arguments: %d\n%s",argc,usage) , exit(1);
    long i=j=0; long n=strtoul(argv[1],NULL,10);
    long num_trials = strtoul(argv[3],NULL,10);
    double start, end, m_tot=0, g_tot=0, c_tot=0;
    TY *array1 = (TY*) malloc (n * sizeof(TY));
    if (array1 == NULL)
        {
            fprintf (stderr,"%zd x %zd: no memory\n", argc, sizeof(TY));
            return 1;
        }
    
    for (i = 0; i < num_trials; i++) {
        fill(argv[2],array1,n);
        start = TIME();
        qsort (array1,n,4,&compare);
        end   = TIME();
        if (i) {
            g_tot += end-start;
        }  
    }
    g_tot /= (double) (num_trials - 1);
    
    for (i = 0; i < num_trials; i++) {
        fill(argv[2],array1,n);
        start = TIME();
        u4_sort (array1,n);
        end   = TIME();
        if (i) {
            m_tot += end - start;
        }    
    }
    m_tot /= (double) (num_trials - 1);
    
    for (i = 1; i < n; i++)
        {
            if (array1[i-1] > array1[i])
                {
                    fprintf (stderr,"ssort: %ld x %zd: failure at offset %ld\n", n,
                             sizeof(TY), i);
                    for (j=0; j < n;j++)
                        fprintf(stderr,"%d ",array1[j]);
                    fprintf(stderr,"\n"); 
                    free(array1);
                    exit(1);
                }
        }
  
        
    for (i = 0; i < num_trials; i++) {
        fill(argv[2],array1,n);
        start = TIME();
        S_SORT (array1,n);
        end   = TIME();
        if (i) {
            c_tot += end - start;
        }    
    }
    c_tot /= (double) (num_trials - 1);
    
    for (i = 1; i < n; i++)
        {
            if (array1[i-1] > array1[i])
                {
                    printf ("csort: %ld x %d: failure at offset %ld\n", n,
                            sizeof(TY), i);
                    for (j=0; j < n;j++)
                        printf("%d ",array1[j]);
                    printf("\n"); 
                    free(array1);
                    return 1;
                }
        }
    
    
    
    fprintf(stdout,"%10ld\t%5.10f\t%5.10f\t%2.2f\t%5.10f\t%2.2f\n",n,m_tot,g_tot,
            100*((g_tot/m_tot) - 1), c_tot, 100 * ((g_tot/c_tot) - 1));
    free (array1);
    return 0; 
}






